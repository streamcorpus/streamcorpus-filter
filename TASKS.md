~~DONE: (by bauer1j)~~
-------
Harness: discuss with bauer1j and make this work again:
 * https://github.com/trec-kba/streamcorpus/tree/v0.3.0-dev/examples/cpp

DONE:  updated from John
That examples relies on these thrift-generated classes, 
 * https://github.com/trec-kba/streamcorpus/tree/v0.3.0-dev/cpp
which are OUT OF DATE, and need to be regenerated using:
  thrift --gen cpp if/streamcorpus-v0_3_0.thrift

~~Phase I:  Initial Tests~~
-----------------------
2. Basic unit test: make trivial string matching baseline that is
O(n*m) as basic test for the harness that reads StreamItems --- make a
simple text and match it.  This unit test can construct a StreamItem
from scratch to pass into the code under test.  Use a testing
framework, such as https://code.google.com/p/googletest/

3. Get an estimate of baseline throughput performance using the TREC
KBA 2013 Rated Documents Corpus described in
[streamcorpus-filter/data/trec-kba-2013-rated-documents.md](data/trec-kba-2013-rated-documents.md)


~~Phase II:  basic use of MultiFast~~
---------------------------------

4. Hook up MultiFast such that it passes the basic unit test.

   http://sourceforge.net/p/multifast/code/HEAD/tree/

5. Get an estimate of baseline throughput perf of MultiFast using the
TREC KBA 2013 Rated Documents Corpus.

This mention-dump file contains all of the mention-->target_id strings
observed in the WLC corpus:
http://aws-publicdatasets.s3.amazonaws.com/trec/kba/wlc/mention-dump.scf.gz

~~Phase 3:  assess dictionary size issues~~
----------------------------------------

7. using list of all titles from WP:

 - how large a data structure does MultiFast make?
 - how fast does it load into memory?
 - how does it interact with character class issues (especially tokenization)?

8. measure throughput against a large portion of the WLC

~~Phase 4:  assess speed of deserialize, match, serialize~~
-------------------------------------------------------

  DE-SERIALIZATION
  test_objects: 197
  time: 0.899386 sec
  objects/sec: 219.038322
  -- items written: 100           avg time per item: 0.066821 sec         items/sec: 14.965304

  SERIALIZATION
  test_objects written: 197
  test_objects: 197
  time: 14.187488 sec
  objects/sec: 13.885474

Phase 5:  assess character class issues
-----------------------------------------

Many StreamItems will fail to match a name string simply because more
than one space appears between the tokens, or because some symbols
have different transliterations.

For each case, we will need to borrow a limited set of regex syntax:

 * http://docs.python.org/2/library/re.html


~~ Phase 5a:
 - make scf2mmap tool
    - create data/names.mmap and data/names_begin.mmap
    - re-run performance test with new names
    - add usage docs in docs/index.txt (in lvvlib)
    - new tests for mmap.h (t-mmap.h in lvvlib)



Phase 5b
- create a single character class for greedy matching between
  name tokens to handle whitespace and other non-word-like characters

 - tokenization between words can vary, e.g. "John Smith" might need
   to be matched as "John[\s\n]Smith" with the "\s" meaning all
   Unicode whitespace:

     * http://en.wikipedia.org/wiki/Space_(punctuation)#Spaces_in_Unicode
     * http://en.wikipedia.org/wiki/Whitespace_character

 - use these test data that are generated by the python test in py/src/tests/streamcorpus_filter/test_streamcorpus_filter.py
     * data/test-name-strings-john-smith-token-boundaries.scf  
     * data/test-stream-items-john-smith-token-boundaries.sc






Phase 5b: handle case insensitivity

 - "John Smith" might need to be matched as "JOHN SMiTH" or "John smith"


Phase 5c: handle more general character classes

 - transliterations: it may be necessary to expand some of the
   characters into classes of characters, such as [e\u00E9\u00C9]


Notes from developer of MultiFast:

> I defined AC_ALPHABET_t type in actypes.h ; you can re-define it
> with whatever you want.  I suggest you to define an enum like this:
>
>     enum MyEnum
>     {
>        MYENUM_TOKEN_1,
>        MYENUM_TOKEN_2,
>     ....
>     };
> 
> and then
> 
>     typedef MyEnum AC_ALPHABET_t;
>
> and devise a pre processing state or tokenizing block. you can
> handle spaces and case sensitivity it that state. after that block
> you have string of tokens instead of bytes.

Phase 6:  assess multi-core matching
------------------------------------

 * phase 6a: design simplest first version
   - here is a strawman design to discuss:
     - single thread reads from stdin and populates a queue with StreamItem objects
     - pool of threads reads from the queue, runs matcher, serializes to
       a buffer, and obtains mutex on stdout in order to write to stdout

 * phase 6b: code cleanup and refactoring to make multi-threading easier and robust
   - comment headers at the top of all files
   - flatten the "lvvlib" dir or rename
   - detailed inline code comments and self-documenting variable names
   - make it generally beautiful, clean, and tight before embarking on multi-threading

 * phase 6c: implement simplest first version multi-core shared memory
   use of MultiFast
   - speed test on AWS EC2 cc2.8xlarge using 32 cores / 64 GB RAM

